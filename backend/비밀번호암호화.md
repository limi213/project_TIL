# :lock: 비밀번호 암호화


회원가입을 구현할 때 입력받는 회원의 비밀번호를 DB에 그대로 저장하는 것은 좋지 않다고 들었다.

DB의 정보가 탈취되었을 때 회원의 중요한 인증정보를 그대로 빼앗기기 때문이다. 

따라서 비밀번호에 암호화를 적용 후 암호화된 상태로 저장하고자 했다.

<br>

## :pencil2: SHA256
현재 프로젝트에서는 회원 기능에 큰 초점을 맞추고 있지 않기 때문에 암호화를 진행했다는 것에 의의를 두었다.

따라서 복잡한 알고리즘을 사용하지 않고 단방향 암호화 알고리즘인 `SHA256`을 사용했다.


SHA256은 해시값을 이용한 단방향 암호화이기 때문에 암호화는 가능하나 복호화가 불가능하다.

이 알고리즘이 좋은 이유는 `abc`와 `abcd`는 비슷하지만 암호화를 적용했을 때 값이 전혀 다른 값으로 나오기 때문이다.

따라서 암호화된 값을 보고 기본의 값을 유추하기가 어렵다

<br>

하지만 이 암호화에는 주의해야 할 점이 있다.

바로 `레인보우 테이블`이 존재한다는 것이다.

이 테이블에는 문자열과 암호화된 값이 매칭되어 저장되어 있다.

따라서 많은 값들이 이 테이블에 쌓이면서 암호화된 값을 보고 기존 문자열을 유추할 수 있게 되었다는 것이다. 

<br>

## :bulb: SALT

단방향 암호화의 문제를 보완하기 위해서 `salt`를 사용했다.

salt는 말 그대로 소금을 쳤다는 것인데,

회원이 입력한 비밀번호에 salt값을 더한 상태로 암호화를 진행한다. 

<br>

이 salt값은 사용자마다 다른 랜덤 값이 부여되고 이를 암호화된 비밀번호와 함께 DB에 저장된다.

이러면 DB가 탈취된다고 해도 기존 암호화되기 전의 비밀번호를 유추하기 어려워진다. 

<br>

## :page_facing_up: Code 

생성된 salt를 이용하여 입력받은 비밀번호를 암호화하여 새로운 문자열을 DB에 저장

```
String salt = SHA256Util.generateSalt();
String newPass = SHA256Util.getEncrypt(requestUser.getPassword(), salt);
```
<br>

로그인 할 때 비밀번호 확인 위해 입력받은 값과 salt를 다시 암호화하여 DB에 저장된 비밀번호와 비교 

```
String inputPass = requestUser.getPassword();
String newPass = SHA256Util.getEncrypt(inputPass, userSalt);

if(newPass.equals(user.getPassword())) return true;
```
